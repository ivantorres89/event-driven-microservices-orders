# Order Process Service

## Purpose

The **Order Process Service** is the **asynchronous processing worker** of the platform.

Its responsibility is to **consume accepted orders from the FIFO queue**, execute the **business transaction** that persists the order in the relational database, update **transient workflow state** for real-time UX, and **publish an `OrderProcessed` completion event** for downstream notification delivery.

This service has **no synchronous HTTP business API**. It runs as a **background worker** and scales horizontally.

---

## Responsibilities

This service is responsible for:

- Subscribing to the `OrderProcessed` FIFO queue and consuming messages asynchronously
- Performing **idempotent** order processing (safe under at-least-once delivery)
- Executing the **OLTP transaction** that persists the order into SQL
- Generating the business `OrderId` **via database-generated primary key**
- Updating transient workflow status in **Redis**:
  - `order:status:{CorrelationId} = PROCESSING`
  - `order:status:{CorrelationId} = COMPLETED`
- Publishing an `OrderProcessed` integration event (includes `CorrelationId` + `OrderId`)
- Emitting logs, traces, and metrics with correlation propagation
- Exposing health endpoints for container orchestration (liveness/readiness)

This service does **not**:

- Accept direct client traffic (no public HTTP API for processing)
- Manage WebSocket connections or push notifications to clients
- Implement authentication/authorization (handled at the gateway edge)
- Use Redis as a system of record

---

## Architectural Role

The Order Process Service is the **persistence and business execution boundary** of the workflow:

- It **owns the relational database schema** for orders (migrations, persistence model, constraints).
- It **converts an accepted request** into a persisted business entity.
- It **emits a completion event** to decouple processing from notification delivery.

This separation allows:

- Fast ingestion (Order Accept returns immediately)
- Ordered, reliable background processing
- Independent scaling of workers vs. API ingress vs. WebSocket servers

---

## Workflow Overview

1. **Order Accept** publishes an `OrderProcessed` message with a `CorrelationId`.
2. This service consumes the message from `OrderProcessed` (FIFO).
3. The service updates Redis workflow state:
   - `order:status:{CorrelationId} = PROCESSING` (TTL-based).
4. The service executes a **single OLTP transaction** to persist the order in SQL:
   - SQL generates the business identifier: `OrderId` (PK).
5. The service updates Redis workflow state:
   - `order:status:{CorrelationId} = COMPLETED`.
6. The service publishes an `OrderProcessed` event to the `OrdersProcessed` FIFO queue.
7. **Order Notification** consumes `OrderProcessed`, resolves the WebSocket session via Redis, and pushes the real-time message to the client.

The client never waits synchronously for steps 2â€“7.

---

## Correlation Model

Two identifiers are used throughout the flow:

| Identifier     | Purpose                         | Generated By           |
|----------------|----------------------------------|------------------------|
| CorrelationId  | Technical workflow correlation   | Order Accept Service   |
| OrderId        | Business identity (PK)           | SQL Database           |

This service must:

- Persist the `CorrelationId` alongside the stored order (for traceability and idempotency).
- Publish both `CorrelationId` and `OrderId` in `OrderProcessed`.

---

## Idempotency Strategy

Message delivery is **at-least-once**, so duplicates are expected.

The consumer is designed to be **idempotent** by using the `CorrelationId` as the stable workflow key:

- The database enforces a unique constraint on `CorrelationId` (or equivalent lookup strategy).
- On processing:
  - If the order for `CorrelationId` does not exist, insert it and obtain the generated `OrderId`.
  - If it already exists, treat the message as a duplicate and **do not create a second order**.
- The service may safely re-publish `OrderProcessed` for duplicates (downstream consumers must also be defensive).

> FIFO ordering ensures predictable processing order. Idempotency ensures correctness under retries and redelivery.

---

## Persistence (SQL)

This service owns persistence for orders.

### Database Guarantees
- SQL is the **system of record**
- Strong consistency for transactional state
- `OrderId` is generated by the database (identity/sequence PK)

### Transaction Boundary
Processing is executed as an OLTP transaction:

- Validate message and map to persistence model
- Insert (or detect existing order via `CorrelationId`)
- Commit
- Publish completion event

> Outbox is not implemented in this service. The design relies on defensive retries and idempotency to tolerate transient publish failures.

---

## Workflow State (Redis)

Redis is used only for **transient workflow state**, enabling:

- Real-time UX for users (status polling / reconnection behavior)
- Shared state across multiple pods (no sticky sessions)

### Keys and Values

**Order workflow state**
- Key: `order:status:{CorrelationId}`
- Values: `ACCEPTED | PROCESSING | COMPLETED`
- TTL: aligned with WebSocket session lifetime (ephemeral)

Redis is **not** a system of record. The authoritative business state remains in SQL.

---

## Messaging

### Queues

- **Inbound**: `OrderProcessed` (FIFO)
- **Outbound**: `OrdersProcessed` (FIFO)

### Broker Choice

- **Azure Service Bus** in production
- **RabbitMQ** for local development and integration testing

Application code depends on messaging **abstractions**, allowing broker replacement without changing business logic.

### Delivery Semantics

- At-least-once delivery
- Consumers must be idempotent
- Poison messages are isolated via **dead-letter queues (DLQ)** and handled operationally

---

## Integration Event Contracts

This service defines/owns the following integration contracts:

### `OrderProcessed` (consumed)
Represents an order that has been accepted at the API boundary.

**Key fields**
- `CorrelationId`
- Order payload (customer, items, etc.)
- Identity context (claims/subject), if propagated from the gateway

### `OrderProcessed` (published)
Represents a successfully persisted order.

**Key fields**
- `CorrelationId`
- `OrderId` (generated by SQL)

This event is consumed by the Notification service to send the final WebSocket update.

---

## Downstream Notifications (SignalR Hub Endpoint)

This service does **not** host WebSockets, but it is part of the real-time chain.

**Canonical SignalR endpoint (notification service):**

- `wss://{host}/hubs/orders`

**Conventions**
- Use `/hubs/{hubName}` for SignalR hubs.
- Secure transport only (`wss`) in non-local environments.
- Authentication is performed using the same JWT access token issued by the IdP and validated at the edge.

**Example (JavaScript SignalR client)**

```js
import * as signalR from "@microsoft/signalr";

const connection = new signalR.HubConnectionBuilder()
  .withUrl("https://api.contoso.com/hubs/orders", {
    accessTokenFactory: () => token
  })
  .withAutomaticReconnect()
  .build();

await connection.start();
```

> The client receives the final `ORDER_COMPLETED` message after `OrderProcessed` is emitted and resolved to a WebSocket session by the notification service.

---

## Design and Code Organization

This service follows **Clean Architecture** principles:

- Message handlers depend on abstractions, not infrastructure
- Use cases are isolated from persistence and broker implementations
- Infrastructure concerns (SQL, Redis, messaging) are injected via interfaces

The codebase follows **SOLID** to maximize:
- Testability
- Clear responsibility boundaries
- Maintainability under change

---

## Stateless Design

The Order Process Service is **stateless**:

- No in-memory workflow state
- No reliance on local caches for correctness

State is externalized to:
- SQL (system of record)
- Redis (transient workflow status)

This supports:
- Horizontal scaling
- Safe restarts
- Predictable behavior under load

---

## Security and Authorization

This service does not validate JWTs directly.

Security is enforced at the **API Gateway layer** (Azure API Management), including:

- JWT validation (issuer, audience, signature)
- Rate limiting / quotas
- Traffic protection

If identity context is required during processing, claims may be propagated from upstream messages.
The service treats internal communication as **zero-trust** and validates required fields at boundaries.

---

## Failure Handling and Resilience

This service depends on critical external infrastructure:

- **Message broker** (to consume and publish events)
- **SQL Database** (system of record)
- **Redis** (workflow state for UX / reconnection)

### Applied Policy (Polly)

#### Broker (consumer + publisher)
- Short timeouts per attempt
- Retries with exponential backoff (transient failures only)
- Consumer acknowledges messages **only after** successful processing

#### SQL
- Short command timeouts
- Retries for transient connectivity errors (careful to avoid retrying non-transient failures)
- Transaction scope kept minimal to reduce lock duration

#### Redis
- Short timeouts
- Limited retries on transient errors
- Fail-fast behavior to avoid resource exhaustion during degradation

> If Redis updates fail after retries, the message is retried. Because processing is idempotent, retries are safe.

---

## Observability

### Logging
- Structured logs
- `CorrelationId` is included in log scopes for end-to-end traceability
- Logs are designed for centralized aggregation (e.g., Azure Monitor)

### Telemetry and Tracing
- OpenTelemetry instrumentation
- Correlation propagated across:
  - message headers
  - logs
  - traces

### Operations
- Dead-letter queues are monitored and treated as an operational workflow.
- `CorrelationId` enables end-to-end troubleshooting across services.

---

## Health Checks

This service exposes health endpoints for Kubernetes:

- **Liveness**: process is running
- **Readiness**: worker is ready to consume messages (basic checks)

Health checks should validate service availability (process + basic wiring), and avoid deep dependency checks that may cause restart loops during partial outages.

---

## Testing Strategy

![All tests passing](../../docs/images/order-process-tests.png)

### Unit Tests
Focus on:
- Message handling behavior
- Idempotency logic
- Mapping and validation
- Error handling paths

External dependencies are mocked via abstractions (SQL repository, broker, Redis client).

### Integration Tests
Validate:
- Consumption and publishing contracts (serialization + headers)
- SQL persistence behavior
- Redis state updates
- End-to-end processing of a single `OrderProcessed` message in a local environment

Integration tests typically run against:
- Local RabbitMQ
- Local Redis
- A local SQL instance (container or developer database)

---

## Out of Scope

This service intentionally does not handle:

- HTTP API exposure to clients
- WebSocket session management
- Real-time message pushing
- API gateway responsibilities (JWT validation, throttling)
- Multi-tenant concerns and advanced authorization policies

---

## Design Philosophy

This service prioritizes:

- Correctness under retries (idempotency)
- Clear transaction boundaries
- Loose coupling via events
- Operational safety and traceability

It is designed to remain simple, predictable, and horizontally scalable.
