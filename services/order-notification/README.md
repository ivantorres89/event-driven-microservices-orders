# Order Notification Service

## Purpose

The **Order Notification Service** provides **real-time, user-facing feedback** for the asynchronous order workflow.

It is responsible for maintaining **WebSocket connections (SignalR, self-hosted)** and pushing **order status updates** to connected clients when downstream processing progresses or completes.

This service performs **no business processing** and is **not a system of record**.

---

## Responsibilities

This service is responsible for:

- Exposing a **SignalR WebSocket hub** for clients (SPA) to connect and receive notifications
- Registering and maintaining **session metadata** in **Redis** to support:
  - multi-pod deployments (no sticky sessions)
  - multi-tab scenarios
  - reconnection and late-join behavior
- Resolving an order workflow by `CorrelationId` and delivering notifications to the correct user/session
- Subscribing to the **order completion** integration event (`OrderProcessed`) from the message broker
- Reading the current transient order workflow state from Redis and emitting a **real-time notification** to the client
- Propagating correlation context into logs/traces for end-to-end observability

This service does **not**:

- Accept orders
- Persist business entities
- Perform synchronous workflow coordination
- Replace the database as the source of truth

---

## Architectural Role

The Order Notification Service is the **real-time edge** of an asynchronous, event-driven workflow.

It bridges:

- **Backend completion events** (message broker)
- **Transient workflow/session state** (Redis)
- **User-facing real-time communication** (WebSockets)

The design enables:

- Horizontal scale-out of WebSocket servers
- Stateless pods (all shared state is externalized)
- Resilient user experience (clients can reconnect and still retrieve current status)

This aligns with the system’s core design decisions: asynchronous processing, stateless services, and Redis used as a short-lived correlation/session registry. 

---

## Workflow Overview

1. The SPA establishes a persistent SignalR connection to the Notification Hub.
2. When an order is submitted and accepted, the client receives a **CorrelationId**.
3. The client binds the CorrelationId to its current WebSocket session (see **Hub Contract**).
4. The **Order Process Service** consumes the accepted order, persists it, and publishes an `OrderProcessed` event.
5. The Notification Service consumes the `OrderProcessed` event.
6. It resolves the associated session via Redis and pushes a real-time message to the client.
7. The client updates the UI (e.g., `COMPLETED`) without polling.

---

## Correlation Model

Two identifiers are used across the platform:

| Identifier     | Purpose                         | Generated By          |
|----------------|---------------------------------|-----------------------|
| CorrelationId  | Technical workflow correlation  | Order Accept API      |
| OrderId        | Business identity               | SQL Database          |

The Notification Service is correlation-driven: it routes notifications using `CorrelationId` and includes `OrderId` only when it becomes available after persistence.

---

## Redis Usage

Redis is used as a **shared, ephemeral registry**. It is not a system of record.

### 1) WebSocket session registry

Maintains the relationship between authenticated users and active SignalR connections.

Example keys (illustrative):

- `ws:connections:{userId}` → set/list of `connectionId` (TTL aligned with session)
- `ws:connection:{connectionId}` → `{ userId, connectedAt }` (TTL)

This enables multi-tab support and reconnection scenarios.

### 2) Order correlation routing

Binds an order workflow (`CorrelationId`) to one or more connections.

- `ws:session:{correlationId}` → `{ userId, connectionId(s) }` (TTL 30–60 minutes)

### 3) Transient workflow state

Reads the transient workflow state maintained by other services:

- `order:status:{correlationId}` → `ACCEPTED | PROCESSING | COMPLETED` (TTL-based)

> Redis is explicitly ephemeral. The SQL database remains the source of truth for business state.

---

## Messaging

This service **subscribes** to completion events:

- Consumes from a **FIFO queue** (Azure Service Bus in production; RabbitMQ locally)
- At-least-once delivery is assumed
- Consumers must be safe under retries (idempotent notification behavior)

### Consumed Integration Event

`OrderProcessed`

Expected payload (conceptual):

```json
{
  "correlationId": "uuid",
  "orderId": 12345,
  "occurredAtUtc": "2026-01-30T12:34:56Z"
}
```

If duplicate events are received, the service should still behave safely (e.g., sending the same notification again is acceptable, or the service can de-dupe using Redis if desired).

---

## SignalR WebSocket API

### Hub Endpoint (standard)

The Notification Hub is exposed under the conventional SignalR path prefix:

- **Hub:** `/hubs/order-status`
- **Negotiate:** `/hubs/order-status/negotiate`

**Connection URL**

- Behind API Gateway / Ingress:  
  `wss://{host}/hubs/order-status`

> The API Gateway and Ingress must allow WebSockets and forward required headers.

### Authentication

Authentication is performed at the edge (API Gateway). The hub expects a valid JWT to be propagated.

SignalR clients typically supply the token via `accessTokenFactory`. Under the hood:
- The negotiate request uses the `Authorization: Bearer <token>` header
- The WebSocket upgrade carries the token as `access_token` in the query string (standard SignalR behavior)

### Hub Contract

**Client → Server**

- `RegisterOrder(correlationId: string)`  
  Binds the received CorrelationId to the caller’s current connection(s) in Redis.

- `GetCurrentStatus(correlationId: string)` (optional)  
  Returns the current transient status from Redis (`ACCEPTED|PROCESSING|COMPLETED`), enabling late-join/reconnect scenarios.

**Server → Client**

- `OrderStatusChanged`  
  Emitted when workflow state changes or completion is observed.

Example payload:

```json
{
  "correlationId": "uuid",
  "orderId": 12345,
  "status": "COMPLETED"
}
```

---

## Stateless Design

The service is fully **stateless**:

- No in-memory session affinity is assumed
- No durable storage is owned here
- All routing/session information is externalized to Redis

This enables safe horizontal scaling of WebSocket pods.

---

## Security and Authorization

- JWT validation is enforced at the API Gateway layer.
- The Notification Service relies on forwarded identity claims (e.g., `sub`) for `userId`.
- Authorization, if needed, is correlation-scoped:
  - A client can only bind or query CorrelationIds that belong to the authenticated user.
  - The mapping `{correlationId -> userId}` in Redis is treated as the enforcement anchor.

---

## Failure Handling

- If Redis is unavailable, the service cannot reliably resolve sessions or statuses:
  - registration calls should fail fast
  - notifications may be dropped (or retried) depending on policy
- If the message broker is unavailable:
  - the consumer is paused and resumes automatically when connectivity returns
- Duplicate events are expected; notification behavior must be retry-safe

Dead-letter queues (DLQ) are treated as an operational concern and monitored separately.

---

## Resilience

This service depends on:

- **Redis**: session + correlation registry (critical)
- **Message broker**: consumes `OrderProcessed` events (critical for notifications)

Typical policies:

- Short timeouts per attempt
- Limited retries with backoff for transient failures
- Circuit breaker around Redis calls to prevent cascade overload

> Outbox is not implemented here. Operational correctness is achieved through at-least-once delivery, idempotent handlers, and fast failure boundaries.

---

## Observability

### Logging

- Structured logging with `CorrelationId` included in scopes
- Logs are designed for centralized aggregation and search

### Telemetry and Tracing

- OpenTelemetry instrumentation at ingress and message-consumer boundaries
- Correlation context propagated across:
  - message consumption
  - Redis interactions
  - hub message emission

This supports end-to-end tracing across logs and traces.

---

## Health Checks

- **Liveness**: process is running
- **Readiness**: service can accept hub connections

Health checks intentionally avoid deep dependency checks (Redis/broker) to prevent restart storms under partial outages.

---

## Testing Strategy

### Unit Tests

Unit tests focus on:

- Session registration behavior
- Redis key/TTL logic
- Message handler behavior (idempotency, contract parsing)
- Hub contract behavior and authorization checks

External dependencies are mocked via abstractions.

### Integration Tests

Integration tests validate:

- SignalR hub connectivity and message contracts
- Redis operations (GET/SET/DEL, TTL behavior)
- Message consumption behavior against a real local broker

---

## Out of Scope

This service intentionally does not handle:

- Order acceptance APIs
- Business processing logic
- Database access as a source of truth
- Workflow orchestration beyond notification routing

---

## Design Philosophy

This service prioritizes:

- Real-time UX without polling
- Stateless scale-out
- Clear responsibility boundaries
- Operational safety in an at-least-once world
