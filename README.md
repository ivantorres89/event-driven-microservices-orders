# Event-Driven Microservices Orders

## Overview

This repository showcases an **event-driven, asynchronous microservices system** designed to process orders at scale while providing **real-time user notifications**.

The project is intended as a **technical portfolio**, demonstrating:

- Backend microservices design
- Event-driven and asynchronous workflows
- Messaging-based integration
- Real-time communication using WebSockets
- Clean service boundaries and stateless services

The implementation is inspired by **real-world cloud-native architectures**, focusing on **system behavior, responsibilities, and interactions** rather than production hardening.

---

## Architecture Context

This repository represents the **implementation layer** of a broader architectural case study.

The **conceptual architecture, requirements, and design decisions** behind this system are documented in a separate repository:

ðŸ‘‰ **Azure Architecture Solutions**  
https://github.com/ivantorres89/azure-architecture-solutions

That repository covers:

- Business and technical requirements
- Architectural trade-offs
- Technology selection rationale
- System diagrams and workflows

This project translates those decisions into a **working, runnable system**.

---

## Problem Statement

The system models a simplified order processing platform with the following constraints:

- Orders must be accepted quickly without blocking the user
- Backend processing is fully asynchronous
- The system must tolerate retries and transient failures
- Users must be notified in real time once processing completes
- Services must remain stateless and independently scalable

---

## High-Level Workflow

1. A client submits an order via HTTP.
2. The system immediately accepts the request and returns a response.
3. The order is published to a FIFO message queue.
4. A background service processes and persists the order.
5. Once processing completes, an event is emitted.
6. A notification service resolves the user session and pushes a WebSocket message to the client.

Two identifiers are used throughout the workflow:

- **CorrelationId** â†’ technical identifier for asynchronous flow tracking
- **OrderId** â†’ business identifier generated by the database

---

## Services Overview

This repository contains **three backend microservices** and a **lightweight frontend application** used to visualize the full end-to-end flow.

### 1. Order Accept Service

- HTTP API for order intake (CRUD-style)
- Generates a `CorrelationId`
- Publishes messages to the order queue
- Performs no synchronous business processing

### 2. Order Process Service

- Background worker service
- Consumes messages asynchronously
- Performs idempotent processing
- Persists orders and emits completion events

### 3. Order Notification Service

- WebSocket server
- Manages client connections
- Uses a Redis backplane for session resolution
- Pushes real-time notifications when orders are completed

### 4. Frontend Application (SPA)

- Minimal Single Page Application
- Allows submitting orders and receiving real-time updates
- Communicates via HTTP and WebSockets
- Exists purely to **demonstrate system behavior**
- Not intended as a production-grade frontend

The frontend is deliberately kept **simple**, as the focus of this repository is backend architecture and distributed systems design.

---

## Identity and Authentication

Authentication is assumed to be handled by an external Identity Provider (IdP).

- OAuth 2.0 / OpenID Connect
- JWT-based access tokens
- Standard claims (issuer, audience, subject)

The Identity Provider itself is out of scope for this project.

The system is designed to remain IdP-agnostic, allowing integration with any standards-compliant provider
(e.g. Azure AD, Keycloak, Auth0).

## Scope and Intent

This repository focuses on:

- Service boundaries
- Communication patterns
- Asynchronous workflows
- Event-driven behavior

The following concerns are intentionally out of scope:

- Production-grade infrastructure sizing
- Advanced Kubernetes topology
- CI/CD pipelines
- Cloud cost optimization
- Those topics are addressed at the architecture level in the companion repository.


## Disclaimer

This repository is provided for portfolio and educational review purposes only.

The code and architecture examples:

- Are not production-ready
- Must not be reused, redistributed, or deployed in real environments
- Do not represent any real customer or system


## Repository Structure

This project is intentionally structured as a **monorepo** for ease of exploration and demonstration.

In a real production environment, each service would typically live in its own repository.


event-driven-microservices-orders/
â”‚
â”œâ”€â”€ README.md                  # Project overview
â”œâ”€â”€ docker-compose.yml         # Run the full system locally
â”‚
â”œâ”€â”€ docs/
â”‚   â””â”€â”€ architecture.md        # Architecture notes and workflows
â”‚
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ order-accept/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â”‚
â”‚   â”œâ”€â”€ order-process/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â”‚
â”‚   â””â”€â”€ order-notification/
â”‚       â”œâ”€â”€ src/
â”‚       â”œâ”€â”€ Dockerfile
â”‚       â””â”€â”€ README.md
â”‚
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ README.md              # Minimal SPA for demo purposes
â”‚
â””â”€â”€ infra/
    â””â”€â”€ local/                 # Local infrastructure (messaging, redis)


