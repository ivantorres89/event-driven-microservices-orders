# Event-Driven Microservices Orders

## Overview

This repository showcases an **event-driven, asynchronous microservices system** designed to process orders at scale while providing **real-time user notifications**.

The project is intended as a **technical portfolio**, demonstrating:

- Backend microservices design
- Event-driven and asynchronous workflows
- Messaging-based integration
- Real-time communication using WebSockets
- Clean service boundaries and stateless services

The implementation is inspired by **real-world cloud-native architectures**, focusing on **system behavior, responsibilities, and interactions** rather than production hardening.

---

## Architecture Context

This repository represents the **implementation layer** of a broader architectural case study.

The **conceptual architecture, requirements, and design decisions** behind this system are documented in a separate repository:

ðŸ‘‰ **Azure Architecture Solutions**  
https://github.com/ivantorres89/azure-architecture-solutions/tree/main/case-studies/k8s-websockets-apporders

That repository covers:

- Business and technical requirements
- Architectural trade-offs
- Technology selection rationale
- System diagrams and workflows

This project translates those decisions into a **working, runnable system**.

---

## Problem Statement

The system models a simplified order processing platform with the following constraints:

- Orders must be accepted quickly without blocking the user
- Backend processing is fully asynchronous
- The system must tolerate retries and transient failures
- Users must be notified in real time once processing completes
- Services must remain stateless and independently scalable

---

## High-Level Workflow

1. A client submits an order via HTTP.
2. The system immediately accepts the request and returns a response.
3. The order is published to a FIFO message queue.
4. A background service processes and persists the order.
5. Once processing completes, an event is emitted.
6. A notification service resolves the user session and pushes a WebSocket message to the client.

Two identifiers are used throughout the workflow:

- **CorrelationId** â†’ technical identifier for asynchronous flow tracking
- **OrderId** â†’ business identifier generated by the database

---

## Services Overview

This repository contains **three backend microservices** and a **lightweight frontend application** used to visualize the full end-to-end flow.

### 1. Order Accept Service

- HTTP API for order intake (CRUD-style)
- Generates a `CorrelationId`
- Publishes messages to the order queue
- Performs no synchronous business processing

### 2. Order Process Service

- Background worker service
- Consumes messages asynchronously
- Performs idempotent processing
- Persists orders and emits completion events

### 3. Order Notification Service

- WebSocket server
- Manages client connections
- Uses a Redis backplane for session resolution
- Pushes real-time notifications when orders are completed

#### Data Ownership
- This service owns the relational database schema and is responsible for:
- Schema creation and migrations
- Persisting business entities
- Emitting domain events after successful persistence

### 4. Frontend Application (SPA)

- Minimal Single Page Application
- Allows submitting orders and receiving real-time updates
- Communicates via HTTP and WebSockets
- Exists purely to **demonstrate system behavior**
- Not intended as a production-grade frontend

The frontend is deliberately kept **simple**, as the focus of this repository is backend architecture and distributed systems design.

---

## Messaging Infrastructure

This system is designed around **asynchronous, message-based communication**.

- **Azure Service Bus** is used in production environments.
- Azure Service Bus does not provide a local development emulator.
- For local development and validation, a **RabbitMQ broker** is provisioned via Docker.

The application code depends exclusively on **messaging abstractions**.
The underlying broker can be replaced without affecting business logic.

RabbitMQ is used **only** for local development and integration testing purposes.

---

## Repository Structure

This project is intentionally structured as a **monorepo** to simplify exploration and demonstration.

In a real production environment, each service would typically live in its own repository.  
For portfolio purposes, a monorepo allows showcasing **end-to-end architecture, service boundaries, and cross-cutting concerns** in a single place.

- **event-driven-microservices-orders/**
  - **README.md**  
    Project overview and architecture summary

  - **docker-compose.yml**  
    Run the full system locally

  - **services/**
    - **order-accept/**
      - **src/**  
        HTTP API for order intake
        - **tests/**
          - **unit/**
            Unit tests focused on service behavior
          - **integration/**
            Integration tests validating messaging contracts
      - **Dockerfile**
      - **README.md**

    - **order-process/**
      - **src/**  
        Asynchronous background worker
      - **tests/**
        - **unit/**
          Unit tests focused on service behavior
        - **integration/**
          Integration tests validating messaging contracts        
      - **Dockerfile**
      - **README.md**

    - **order-notification/**
      - **src/**  
        WebSocket notification service
      - **tests/**
        - **unit/**
          Unit tests focused on service behavior
        - **integration/**
          Integration tests validating messaging contracts
      - **Dockerfile**
      - **README.md**

  - **frontend/**
    - **src/**  
      Minimal SPA for demo purposes
    - **Dockerfile**
    - **README.md**

  - **infra/**
    - **local/**  
      Local infrastructure (RabbitMQ, Redis)

---

## Testing Strategy

This repository applies a **layered testing approach**:

### Unit Tests
- Validate service behavior in isolation
- Focus on domain logic, request validation, and error handling
- External dependencies are mocked via abstractions

### Integration Tests
Integration tests are intentionally **limited in scope** and focus on validating:

- HTTP request handling at service boundaries
- Message publishing and consumption behavior
- Messaging contracts and serialization
- Interaction with a real message broker

Integration tests **do not** cover:
- Frontend behavior
- End-to-end user workflows
- Cloud infrastructure provisioning
- Azure-managed services

Their purpose is to validate **service contracts and distributed behavior**, not infrastructure correctness.

---

## Identity and Authentication

Authentication is assumed to be handled by an external Identity Provider (IdP).

- OAuth 2.0 / OpenID Connect
- JWT-based access tokens
- Standard claims (issuer, audience, subject)

The Identity Provider itself is out of scope for this project.

The system is designed to remain IdP-agnostic, allowing integration with any standards-compliant provider
(e.g. Azure AD, Keycloak, Auth0).

## Scope and Intent

This repository focuses on:

- Service boundaries
- Communication patterns
- Asynchronous workflows
- Event-driven behavior

The following concerns are intentionally out of scope:

- Production-grade infrastructure sizing
- Advanced Kubernetes topology
- CI/CD pipelines
- Cloud cost optimization
- Those topics are addressed at the architecture level in the companion repository.


## Disclaimer

This repository is provided for portfolio and educational review purposes only.

The code and architecture examples:

- Are not production-ready
- Must not be reused, redistributed, or deployed in real environments
- Do not represent any real customer or system


