# Contoso Shop — Full workflow (userId + correlationId + orderId)

This document explains, step by step and “low level”, what **each microservice** does and what happens in **SignalR**, **Redis**, and **SQL (Azure SQL / SQL Server)** from the moment the SPA creates an order until the notification arrives.

---

## Components (who is who)

- **SPA (Angular)**
  - Sends `POST /api/orders` to **order-accept** with a JWT.
  - Opens a **WSS** (SignalR) channel with **order-notification** to receive notifications.
  - Uses `correlationId` to correlate “my order” in the UI.

- **order-accept**
  - Is the **entry point**.
  - Generates `correlationId`.
  - Writes to **Redis** the mapping **`correlationId → userId`** (TTL).
  - Publishes the **order.accepted** event (without `userId`).

- **order-process**
  - Consumes **order.accepted**.
  - Persists **Order + OrderItems** in **SQL**.
  - Publishes **order.processed** (with `correlationId + orderId`, without `userId`).
  - Updates **status** in Redis and refreshes the TTL of the mapping.

- **order-notification**
  - Hosts the **SignalR Hub**.
  - Consumes **order.processed**.
  - Resolves `userId` from **Redis** using `correlationId`.
  - Notifies via SignalR using `Clients.User(userId)`.

---

## Identifiers: what they mean

- **userId**: the user identifier (the `sub` claim / `Customer.ExternalCustomerId` from the JWT).  
  Used to route notifications through SignalR: `Clients.User(userId)`.

- **correlationId (UUID)**: technical identifier used to correlate the async workflow.  
  It is generated by **order-accept** and travels through the events.

- **orderId**: the order id (PK in SQL).  
  It is created when the order is persisted in SQL (order-accept) and propagated in later events.

> Important: **SQL is the Source of Truth (SoR)**.  
> Redis is **ephemeral** (TTL) and is used to “resolve fast” and for transient state.

---

## Redis: keys and TTL (what we store)

Recommended keys:

- `order:status:{correlationId}` = `ACCEPTED | PROCESSING | COMPLETED` (TTL)
- `order:map:{correlationId}` = `{userId}` (TTL)  ✅ critical key for notifications
- (optional) `order:id:{correlationId}` = `{orderId}` (TTL)
- (optional) `order:last:{userId}` = `{correlationId}` (TTL)

Typical TTL: **30–60 minutes**.  
Also, **order-process refreshes the TTL** so the mapping doesn’t expire if processing takes long.

---

## SignalR: how it routes to a user (pattern B)

In the **order-notification** Hub:

1) The SPA connects over WSS using a JWT.
2) The Hub sets `Context.UserIdentifier` (usually from the JWT `sub`).
3) When the worker needs to notify that user, it calls:

```csharp
await hubContext.Clients.User(userId)
    .SendAsync("orderCompleted", payload);
```

**Result:** all active connections for that `userId` (multi-tab, multi-device) receive the message.

---

# Full workflow (step by step)

## 0) The SPA opens the WSS channel (SignalR)

**SPA → order-notification Hub (WSS):**
- Connects with a JWT.
- The Hub takes `sub` (ExternalCustomerId) and uses it as the `UserIdentifier`.

**What happens internally:**
- SignalR creates one connection per tab/window (or per device).
- All those connections hang off the same `userId`.

> If the user closes the browser, that connection drops.  
> **Nothing is stored in Redis just because the client is connected** (unless you implement explicit presence).

---

## 1) The SPA creates an order

**SPA → order-accept:**
```
POST /api/orders
Authorization: Bearer <JWT>
Body: { items: [...], shipping: {...}, ... }
```

### 1.1) order-accept validates identity
- Extracts `userId` from the JWT (the `sub` claim / ExternalCustomerId).
- **Does not trust** a `CustomerId` coming from the body (if there were one).

### 1.2) order-accept generates correlationId
Example:
- `correlationId = "9e9b0b12-7a3c-4e07-8f47-6e6c6b8c2d77"`

### 1.3) order-accept writes to Redis (operational / ephemeral)
With TTL (e.g., 45 min):

- `SET order:map:{correlationId} {userId} EX 2700`
- `SET order:status:{correlationId} ACCEPTED EX 2700`
- (optional) `SET order:id:{correlationId} {orderId} EX 2700`

Real example:
- `order:map:9e9b0b12-... = user-123`
- `order:status:9e9b0b12-... = ACCEPTED`
- `order:id:9e9b0b12-... = 41827`

### 1.4) order-accept publishes the order.accepted event (RabbitMQ)
**Without `userId`** (so identity is not propagated):

Example payload:
```json
{
  "correlationId": "9e9b0b12-7a3c-4e07-8f47-6e6c6b8c2d77",
  "orderId": 41827
}
```

### 1.5) order-accept responds to the SPA
HTTP 201:
```json
{
  "id": 41827,
  "correlationId": "9e9b0b12-7a3c-4e07-8f47-6e6c6b8c2d77"
}
```

**The SPA** stores these values for the UI and correlation.

---

## 2) order-process consumes order.accepted and processes

**RabbitMQ → order-process:**
- Consumes `order.accepted(correlationId, orderId)`.

### 2.1) order-process sets PROCESSING (Redis)
- `SET order:status:{correlationId} PROCESSING EX <ttl>`
- **Refreshes the TTL** of the mapping (without changing it):
  - `EXPIRE order:map:{correlationId} <ttl>`
  - (optional) `EXPIRE order:id:{correlationId} <ttl>`

This prevents the issue: “it took more than 30 minutes and the mapping expired”.

### 2.2) order-accept writes to SQL (SoR)
- Inserts `Order` + `OrderItems` into Azure SQL.
- Gets `orderId` (PK) from the table.

Example:
- `orderId = 41827`

SQL remains the SoR for:
- `orderId ↔ userId`
- `orderId ↔ correlationId`
- items, totals, etc.

### 2.3) order-process finishes and publishes order.processed
When it finishes:
- `SET order:status:{correlationId} COMPLETED EX <ttl>`
- `EXPIRE order:map:{correlationId} <ttl>` (final refresh)

Publishes:
```json
{
  "correlationId": "9e9b0b12-7a3c-4e07-8f47-6e6c6b8c2d77",
  "orderId": 41827
}
```

---

## 3) order-notification consumes order.processed and notifies via SignalR

**RabbitMQ → order-notification (worker):**
- Receives `order.processed(correlationId, orderId)`.

### 3.1) order-notification resolves userId in Redis
It does:
- `GET order:map:{correlationId}`

If it exists:
- returns `userId = "user-123"`

### 3.2) order-notification sends via SignalR
Using HubContext:
```csharp
await hubContext.Clients.User("user-123")
    .SendAsync("orderCompleted", new {
        orderId = 41827,
        correlationId = "9e9b0b12-..."
    });
```

### 3.3) What the SPA receives
In any tab connected as `user-123`, something like this arrives:
```json
{
  "orderId": 41827,
  "correlationId": "9e9b0b12-..."
}
```

The SPA:
- marks the order as completed in the UI,
- optionally queries the backend for final details.

---

# What if Redis does NOT return userId?
## Does the WebSocket (WSS) drop?
**NO.**  
The WebSocket is between **SPA ↔ SignalR Hub**.  
The Redis failure happens in the **worker** consuming RabbitMQ. They are separate paths.

## What actually happens?
1) `order-notification` receives the event.
2) It does `GET order:map:{cid}` and gets `null`.
3) It does **short retries** (in case it’s a temporary race):
   - 100ms → 250ms → 500ms (example)
4) If it’s still `null`, the consumer:
   - **does NOT ACK** the message (throws)
   - RabbitMQ retries it according to policy
   - if retries are exhausted, it goes to the **DLQ**

**Result:**
- No notification (yet), but it is **not silently lost**: it remains for retry / DLQ.

## And if the user was connected to SignalR?
It doesn’t matter: without `userId` we don’t know who to send it to.  
The connection stays alive, but the message is never sent.

---

# “One-liner” summary per microservice

- **SPA**: connects SignalR + posts order + receives notification by `correlationId`.
- **order-accept**: JWT → `userId`; generates `correlationId`; persists to SQL; writes Redis `cid→userId`; publishes event.
- **order-process**: consumes event; updates status; refreshes mapping TTL; publishes processed.
- **order-notification**: consumes processed; looks up `userId` in Redis; `Clients.User(userId)`.

---

# Quick checklist (the minimum to make it work)

1) In **order-accept**:
   - write `order:map:{cid} = userId` with TTL
   - write `order:status:{cid} = ACCEPTED` with TTL

2) In **order-process**:
   - refresh TTL for `order:map:{cid}` on PROCESSING/COMPLETED

3) In **order-notification**:
   - use `order:map:{cid}` to resolve `userId`
   - retry + DLQ if the mapping is missing

4) In the Hub:
   - make sure `Context.UserIdentifier` == JWT `sub`

---

## Appendix: full example with values

**JWT sub:** `user-123`  
**correlationId:** `9e9b0b12-7a3c-4e07-8f47-6e6c6b8c2d77`  
**orderId:** `41827`

Redis:
- `order:map:9e9b0b12-... = user-123`
- `order:status:9e9b0b12-... = COMPLETED`
- `order:id:9e9b0b12-... = 41827` (optional)

Processed event:
```json
{
  "correlationId": "9e9b0b12-...",
  "orderId": 41827
}
```

SignalR:
```csharp
Clients.User("user-123").SendAsync("orderCompleted", { orderId, correlationId });
```
