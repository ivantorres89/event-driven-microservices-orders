# Contoso Shop — Full workflow (userId + correlationId + orderId)

This document explains, step by step and “low level”, what **each microservice** does and what happens in **SignalR**, **Redis**, and **SQL (Azure SQL / SQL Server)** from the moment the SPA creates an order until the notification arrives.

---

## “One-liner” summary per microservice

- **SPA**: connects SignalR + posts order + receives notification by `correlationId`.
- **order-accept**: JWT → `userId`; generates `correlationId`; writes Redis `order:map:{correlationId}` & `order:status:{correlationId}`; publishes event.
- **order-process**: consumes event; updates statuses in Redis; persists to SQL database; refreshes mapping TTL; publishes processed.
- **order-notification**: consumes processed; looks up `userId` in Redis; `Clients.User(userId)`.

---

## Components (who is who)

- **SPA (Angular)**
  - Sends `POST /api/orders` to **order-accept** with a JWT.
  - Opens a **WSS** (SignalR) channel with **order-notification** to receive notifications.
  - Uses `correlationId` to correlate “my order” in the UI.

- **order-accept**
  - Is the **entry point**.
  - Generates `correlationId`.
  - Writes to **Redis** the mapping **`correlationId → userId`** (TTL).
  - Publishes the **order.accepted** event (without `userId`).

- **order-process**
  - Consumes **order.accepted**.
  - Persists **Order + OrderItems** in **SQL**.
  - Publishes **order.processed** (with `correlationId + orderId`, without `userId`).
  - Updates **status** in Redis and refreshes the TTL of the mapping.

- **order-notification**
  - Hosts the **SignalR Hub**.
  - Consumes **order.processed**.
  - Resolves `userId` from **Redis** using `correlationId`.
  - Notifies via SignalR using `Clients.User(userId)`.

---

## Identifiers: what they mean

- **userId**: the user identifier (the `sub` claim / `Customer.ExternalCustomerId` from the JWT).  
  Used to route notifications through SignalR: `Clients.User(userId)`.

- **correlationId (UUID)**: technical identifier used to correlate the async workflow.  
  It is generated by **order-accept** and travels through the events.

- **orderId**: the order id (PK in SQL).  
  It is created when the order is persisted in SQL (order-accept) and propagated in later events.

> Important: **SQL is the Source of Truth (SoR)**.  
> Redis is **ephemeral** (TTL) and is used to “resolve fast” and for transient state.

---

## Redis: keys and TTL (what we store)

Used keys:

- `order:status:{correlationId}` = `ACCEPTED | PROCESSING | COMPLETED` (TTL)
- `order:map:{correlationId}` = `{userId}` (TTL) critical key for notifications

A screenshot of how looks like Redis:

![Redis Business keys](/docs/images/redis_business_keys.png)

Typical TTL: **30–60 minutes**.  
Also, **order-process refreshes the TTL** so the mapping doesn’t expire if processing takes long.

---

## SignalR: how it routes to a user (pattern B)

In the **order-notification** Hub:

1) The SPA connects over WSS using a JWT.
2) The Hub sets `Context.UserIdentifier` (usually from the JWT `sub`).
3) When the worker needs to notify that user, it calls:

```csharp
await hubContext.Clients.User(userId)
    .SendAsync("orderCompleted", payload);
```

**Result:** all active connections for that `userId` (multi-tab, multi-device) receive the message.

### Multi-pod delivery (Redis backplane)

When `order-notification` runs with multiple replicas (multiple Hub instances), a single browser tab is connected to **one** pod, but different tabs (or devices) can be connected to **different** pods.

To ensure `Clients.User(userId)` reaches **all** of a user’s active connections across all pods, SignalR uses **Redis pub/sub as a backplane**:

1) The pod that executes `Clients.User(userId)` publishes the message to Redis pub/sub.
2) Every `order-notification` pod is subscribed to the channel {contoso-signalROrderNotification} and receives the message. 

We can see on Redis Pub/Sub the following serialized payload in the channel:

![Redis Pub/Sub](/docs/images/redis_backplane/redis_pub_sub_01.png)

Order is submitted with correlationId {375e...} 

![Redis Pub/Sub Order submitted](/docs/images/redis_backplane/redis_pub_sub_02.png)

3) Each pod gets the message and forwards it only to its **local** WebSocket connections whose `Context.UserIdentifier == userId`.

The backplane channels are isolated using a Redis `ChannelPrefix` (e.g. `contoso-signalr`) so backplane traffic does not collide with other Redis usage (like `order:*` keys).

---

# Full workflow (step by step)

## 0) The SPA opens the WSS channel (SignalR)

**SPA → order-notification Hub (WSS):**
- The SPA opens a **WebSocket (WSS)** connection to the SignalR Hub and authenticates with a JWT.
- The Hub derives `Context.UserIdentifier` from the JWT (typically the `sub` claim / ExternalCustomerId).

**What happens with WebSocket “sessions” (per tab / per pod):**
- **One browser tab = one SignalR connection.** If the user opens 2 tabs, there are 2 independent WebSocket connections.
- In a scaled deployment, each WebSocket is accepted by **one** `order-notification` pod. Different tabs can end up connected to different pods.
- Connections are long-lived: once a WebSocket is established, it stays attached to that pod until it disconnects.

**How notifications still reach all tabs (Redis + backplane):**
- The worker notifies users with `Clients.User(userId)`.
- With a Redis backplane enabled, the sending pod publishes the notification over Redis pub/sub (using a `ChannelPrefix`, e.g. `contoso-signalr`).
- Every `order-notification` pod receives that backplane message and delivers it to its **local** connections for that user.
- Result: **all tabs** for the user get the notification even if they are connected to different pods.

**What happens if the connected pod goes away:**
- If a pod is terminated (scale-in) or the network drops, the WebSocket disconnects and the SPA’s reconnect logic establishes a **new** WebSocket (which may land on a different pod).
- After reconnect, the SPA can refresh the current order status; Redis stores transient workflow state (e.g. `order:status:{correlationId}` and `order:map:{correlationId}`) with TTL, so the UI can rehydrate even after brief disconnects.

---

## 1) The SPA creates an order

**SPA → order-accept:**
```
POST /api/orders
Authorization: Bearer <JWT>
Body: { items: [...], shipping: {...}, ... }
```

### 1.1) order-accept validates identity
- Extracts `userId` from the JWT (the `sub` claim / ExternalCustomerId).
- **Does not trust** a `CustomerId` coming from the body (if there were one).

### 1.2) order-accept generates correlationId
Example:
- `correlationId = "9e9b0b12-7a3c-4e07-8f47-6e6c6b8c2d77"`

### 1.3) order-accept writes to Redis (operational / ephemeral)
With TTL (e.g., 45 min):

- `SET order:map:{correlationId} {userId} EX 2700`
- `SET order:status:{correlationId} ACCEPTED EX 2700`

Real example:
- `order:map:9e9b0b12-... = user-123`
- `order:status:9e9b0b12-... = ACCEPTED`
- `order:id:9e9b0b12-... = 41827`

### 1.4) order-accept publishes the order.accepted event (RabbitMQ)
**Without `userId`** (so identity is not propagated):

Example payload:
```json
{
  "correlationId": "9e9b0b12-7a3c-4e07-8f47-6e6c6b8c2d77",
  "orderId": 41827
}
```

### 1.5) order-accept responds to the SPA
HTTP 201:
```json
{
  "id": 41827,
  "correlationId": "9e9b0b12-7a3c-4e07-8f47-6e6c6b8c2d77"
}
```

**The SPA** stores these values for the UI and correlation.

---

## 2) order-process consumes order.accepted and processes

**RabbitMQ → order-process:**
- Consumes `order.accepted(correlationId, orderId)`.

### 2.1) order-process sets PROCESSING (Redis)
- `SET order:status:{correlationId} PROCESSING EX <ttl>`
- **Refreshes the TTL** of the mapping (without changing it):
  - `EXPIRE order:map:{correlationId} <ttl>`

This prevents the issue: “it took more than 30 minutes and the mapping expired”.

### 2.2) order-process writes to SQL (SoR)
- Inserts `Order` + `OrderItems` into Azure SQL/SQL Server.
- Gets `orderId` (PK) from the table.

Example:
- `orderId = 41827`

SQL remains the SoR for:
- `orderId ↔ userId`
- `orderId ↔ correlationId`
- items, totals, etc.

### 2.3) order-process finishes and publishes order.processed
When it finishes:
- `SET order:status:{correlationId} COMPLETED EX <ttl>`
- `EXPIRE order:map:{correlationId} <ttl>` (final refresh)

Publishes:
```json
{
  "correlationId": "9e9b0b12-7a3c-4e07-8f47-6e6c6b8c2d77",
  "orderId": 41827
}
```

---

## 3) order-notification consumes order.processed and notifies via SignalR

**RabbitMQ → order-notification (worker):**
- Receives `order.processed(correlationId, orderId)`.

### 3.1) order-notification resolves userId in Redis
It does:
- `GET order:map:{correlationId}`

If it exists:
- returns `userId = "user-123"`

### 3.2) order-notification sends via SignalR
Using HubContext:
```csharp
await hubContext.Clients.User("user-123")
    .SendAsync("orderCompleted", new {
        orderId = 41827,
        correlationId = "9e9b0b12-..."
    });
```

### 3.3) What the SPA receives
In any tab connected as `user-123`, something like this arrives:
```json
{
  "orderId": 41827,
  "correlationId": "9e9b0b12-..."
}
```

The SPA:
- marks the order as completed in the UI,
- optionally queries the backend for final details.

---

# What if Redis does NOT return userId?
## Does the WebSocket (WSS) drop?
**NO.**  
The WebSocket is between **SPA ↔ SignalR Hub**.  
The Redis failure happens in the **worker** consuming RabbitMQ. They are separate paths.

## What actually happens?
1) `order-notification` receives the event.
2) It does `GET order:map:{cid}` and gets `null`.
3) It does **short retries** (in case it’s a temporary race):
   - 100ms → 250ms → 500ms (example)
4) If it’s still `null`, the consumer:
   - **does NOT ACK** the message (throws)
   - RabbitMQ retries it according to policy
   - if retries are exhausted, it goes to the **DLQ**

**Result:**
- No notification (yet), but it is **not silently lost**: it remains for retry / DLQ.

## And if the user was connected to SignalR?
It doesn’t matter: without `userId` we don’t know who to send it to.  
The connection stays alive, but the message is never sent.

---

# “One-liner” summary per microservice

- **SPA**: connects SignalR + posts order + receives notification by `correlationId`.
- **order-accept**: JWT → `userId`; generates `correlationId`; persists to SQL; writes Redis `cid→userId`; publishes event.
- **order-process**: consumes event; updates status; refreshes mapping TTL; publishes processed.
- **order-notification**: consumes processed; looks up `userId` in Redis; `Clients.User(userId)`.

---

## Appendix: full example with values

**JWT sub:** `user-123`  
**correlationId:** `9e9b0b12-7a3c-4e07-8f47-6e6c6b8c2d77`  
**orderId:** `41827`

Redis:
- `order:map:9e9b0b12-... = user-123`
- `order:status:9e9b0b12-... = COMPLETED`
- `order:id:9e9b0b12-... = 41827` (optional)

Processed event:
```json
{
  "correlationId": "9e9b0b12-...",
  "orderId": 41827
}
```

SignalR:
```csharp
Clients.User("user-123").SendAsync("orderCompleted", { orderId, correlationId });
```
