# Contoso Order Processing Platform  
## Cloud-Native Asynchronous Architecture

---

## Overview

This repository presents a **cloud-native, asynchronous order processing architecture** designed for **high-throughput transactional workloads** and **real-time user notifications**, deployed on Microsoft Azure.

The architecture reflects **real-world enterprise design patterns**, focusing on:
- Event-driven processing
- Clear separation of concerns
- Scalability and resilience
- Secure exposure of backend services

This repository intentionally focuses on **architecture and design decisions**, not on application source code or implementation details.

---

## Problem Context

Contoso needs to build a backend platform capable of handling a large volume of customer orders while ensuring:

- A responsive frontend experience
- Protection of backend systems from traffic spikes
- Reliable, ordered, and idempotent processing
- Real-time feedback to end users once processing completes
- The system must allow users to retrieve the current order status at any time, regardless of browser tab, window, or WebSocket reconnection.

The system must remain stable under load and tolerate retries, failures, and partial outages without impacting the user experience.

---

## Functional Requirements

### Order Submission
- Orders are submitted via a Single Page Application (SPA).
- Submission is non-blocking.
- The frontend does not wait for backend processing to complete.

### Order Processing
- Orders are processed asynchronously.
- FIFO semantics are required.
- Duplicate message delivery must be handled safely.

### User Notification
- Users receive a real-time notification when their order processing completes.
- Notifications are delivered via WebSockets.
- The service uses SignalR (self-hosted) for WebSocket management. Azure SignalR Service (PaaS) is intentionally not used to keep the architecture explicit and portable.

---

## Non-Functional Requirements

- Horizontal scalability
- Fault tolerance
- Loose coupling between components
- Strong consistency for transactional data
- Predictable performance under sustained load
- Secure communication by default

---

## Identity and Authentication (Out of Scope)

User authentication and token issuance are performed by an **external Identity Provider (IdP)**.

The architecture assumes:
- OAuth 2.0 / OpenID Connectâ€“compliant access tokens
- JWT-based authentication
- Standard claims (e.g. user identity, scopes, issuer)

The **Identity Provider itself is intentionally out of scope** for this case study.  
The system is designed to remain **agnostic to the specific IdP implementation**, allowing integration with any standards-compliant provider.

---

## Architectural Overview

The system follows an **event-driven, asynchronous architecture**:

1. The SPA establishes a WebSocket connection with the backend.
2. The user submits an order via HTTP.
3. The API boundary generates a **CorrelationId**.
4. The order request is published to a FIFO message queue.
5. Backend processors consume and process the order asynchronously.
6. The order is persisted in the database, generating the business `OrderId`.
7. An order completion event is published.
8. A notification service resolves the WebSocket session and pushes a real-time update to the user.

---

## Identity and Correlation Model

Two identifiers are intentionally used:

| Identifier | Purpose | Generated By |
|----------|--------|--------------|
| CorrelationId | Technical workflow correlation | Order Accept API |
| OrderId | Business identity | SQL Database |

This separation allows orders to be accepted and tracked **before database interaction**, while keeping business identity generation within the persistence layer.

---

## Core Components

### Client Application
- SPA communicating via HTTP and WebSockets.
- Maintains a persistent WebSocket connection for notifications.

### API Gateway (Edge Layer)
- Azure API Management.
- Acts as a **public perimeter gateway**.
- Responsibilities:
  - JWT validation
  - Rate limiting and quotas
  - Traffic protection
  - Forwarding authenticated requests to the Kubernetes cluster
- Contains no business or domain logic.

### Application Runtime (AKS)

All backend workloads run on **Azure Kubernetes Service**:

- Order Accept API
- Order Processing workers
- Real-time Notification service (WebSocket servers)

Services are stateless and scale horizontally using Kubernetes primitives.

A single AKS cluster is shown in the diagram for clarity.  
Zonal or multi-cluster deployments are intentionally omitted to keep the focus on logical architecture rather than physical topology.

### Messaging
- Azure Service Bus queues with FIFO semantics.
- At-least-once delivery.
- Built-in retry and dead-letter support.

### Data Storage
- Azure SQL Database (Business Critical tier).
- Strong consistency guarantees.
- Database-generated primary keys.

### Redis
- Azure Cache for Redis.
- Used as a **short-lived session and correlation registry**.
- Maps CorrelationId to WebSocket connection metadata.
- TTL-based cleanup.

Redis is not used as a message broker or system of record.

---

## Scope and Intent

This architecture focuses on **system behavior and responsibility boundaries**.

Details such as:
- Infrastructure sizing
- Node-level configuration
- CI/CD pipelines
- Infrastructure as Code

are considered out of scope unless they materially affect architectural decisions.

---
